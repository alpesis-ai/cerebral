#include <math.h>
#include <random>

#include <cuda_runtime.h>
#include "cublas_v2.h"

#include "elm.h"
#include "../utils/matrix_printer.h"
#include "../nn/math/matrix_gpu.h"


using namespace std;

// ---------------------------------------------------------------------------
// initialize network



// initialize weights and bias
void ELM::init_nn_params_gpu()
{
    // generate the weights
    h_weight = (float*)malloc(N_Hidden * Dim * sizeof(float));
    cudaMalloc(&d_weight, N_Hidden * Dim * sizeof(float));
    fill_rand_gpu(d_weight, N_Hidden, 1);
    cudaMemcpy(h_weight, d_weight, N_Hidden * Dim * sizeof(float), cudaMemcpyDeviceToHost);
    

    // generate the bias
    h_bias = (float*)malloc(N_Hidden * 1 * sizeof(float));
    cudaMalloc(&d_bias, N_Hidden * 1 * sizeof(float));
    fill_rand_gpu(d_bias, N_Hidden, 1);
    cudaMemcpy(h_bias, d_bias, N_Hidden * 1 * sizeof(float), cudaMemcpyDeviceToHost);
}


void ELM::config_nn_gpu(uint16_t n_hidden, uint16_t dim, uint16_t n_samples)
{
    set_dim(n_hidden, dim, n_samples);
    init_nn_params_gpu();
}


// ---------------------------------------------------------------------------
// train/test: GPU


bool ELM::train_gpu(mat &train_X, mat &train_Y, uint16_t activation)
{
    wall_clock timer;
    mat param;

    // allocate host memory
    float *h_train_X = (float*)malloc(train_X.n_rows * train_X.n_cols * sizeof(float));
    float *h_train_Y = (float*)malloc(train_Y.n_rows * train_Y.n_cols * sizeof(float));


    // allocate device memory
    float *d_train_X;
    float *d_train_Y;
    float *d_hidden;
    float *d_weight_t;
    // cudaMalloc(&d_train_X, train_X.n_rows * train_X.n_cols * sizeof(float));
    // cudaMalloc(&d_train_Y, train_Y.n_rows * train_Y.n_cols * sizeof(float));
    // cudaMalloc(&d_hidden, train_X.n_rows * N_Hidden * sizeof(float));
    // cudaMalloc(&d_weight_t, N_Hidden * Dim * sizeof(float));

    // cudaMemcpy(d_train_X, h_train_X, train_X.n_rows, train_X.n_cols * sizeof(float), cudaMemcpyHostToDevice);
    // cudaMemcpy(d_train_Y, h_train_Y, train_Y.n_rows, train_Y.n_cols * sizeof(float), cudaMemcpyHostToDevice);

    timer.tic();
        // weight_t: transpose weight
        cublas_sgeam(d_weight, d_weight_t, N_Hidden, Dim);
        // pre_hidden = train_X * weight.t()
        cublas_mmul(d_train_X, d_weight_t, d_hidden, train_X.n_rows, train_X.n_cols, N_Hidden);

        param = train_X * weight.t(); 
        mat hidden = zeros(N_Samples, N_Hidden);

        double alpha = 0.2;
        double lambda = 5;
        activation = activation;

        cout << "activation: " << activation << endl;
        switch (activation)
        {
            case 0: // sigmoid
                for (int i = 0; i < hidden.n_rows; ++i)
                {
                    for (int j = 0; j < hidden.n_cols; ++j)
                    {
                        hidden(i, j) = 1.0 / (1.0 + exp(-(param(i,j) + bias(j))));
                    }
                }
                break;

            default:
                cout << "undefined activation function." << endl;
                return false;
        }

        mat hidden_inv = pinv(hidden);
        // cout << "hidden pseudoinverse: " << hidden_inv;

        beta = hidden_inv * train_Y;
        // cout << "beta: " << beta << endl;

    train_time = timer.toc();

    mat Y_hat = hidden * beta;
    vec temp = train_Y - Y_hat;

    double error = stddev(temp);
    cout << "(Train) RMSE = " << error << endl;
    cout << "Training time = " << train_time << endl;

    save_model();

    return true;
        
}


bool ELM::test_gpu(mat &test_X, mat &test_Y, uint16_t activation)
{
    wall_clock timer;
    mat param;

    timer.tic();
        param = test_X * weight.t();
        mat hidden = zeros(N_Samples, N_Hidden);

        double alpha = 0.2;
        double lambda = 5;

        cout << "activation: " << activation << endl;
        switch(activation)
        {
            case 0:  // sigmoid
                for (int i = 0; i < hidden.n_rows; ++i)
                {
                    for (int j = 0; j < hidden.n_cols; ++j)
                    {
                        hidden(i, j) = 1.0 / (1.0 + exp(-(param(i,j) + bias(j))));
                    }
                }
                break;

            default:
                cout << "undefined activation function." << endl;
                return false;
        }

    test_time = timer.toc();
    
    mat Y_hat = hidden * beta;
    vec temp = test_Y - Y_hat;

    double error = stddev(temp);
    cout << "Test RMSE = " << error << endl;
    cout << "Testing time = " << test_time << " seconds." << endl;

    Y_hat.save("y_hat.csv", csv_ascii);

    return true;
}


